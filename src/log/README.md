# 日志书写

## `block_queue`类

### `block_queue(int max_size = 1000)`

- 作用：构造函数用于创建`block_queue`对象。
- 实现：初始化`m_max_size`为传入的`max_size`，动态分配大小为`max_size`的元素数组`m_array`，并初始化其他成员变量，如`m_size`、`m_front`和`m_back`。

### `void clear()`

- 作用：清空队列，将队列的大小和指针重新设置为初始状态。
- 实现：获取互斥锁，将`m_size`、`m_front`和`m_back`均重置为初始值，然后释放互斥锁。

### `~block_queue()`

- 作用：析构函数负责释放队列相关的资源，包括队列元素数组。
- 实现：获取互斥锁，释放动态分配的队列元素数组，并释放互斥锁。

### `bool full()`

- 作用：判断队列是否已满。
- 实现：获取互斥锁，如果`m_size`大于等于`m_max_size`，表示队列已满，返回`true`，否则返回`false`，然后释放互斥锁。

### `bool empty()`

- 作用：判断队列是否为空。
- 实现：获取互斥锁，如果`m_size`为零，表示队列为空，返回`true`，否则返回`false`，然后释放互斥锁。

### `bool front(T &value)`

- 作用：获取队列的队首元素，并将其存储在传入的`value`参数中。
- 实现：获取互斥锁，如果`m_size`为零，表示队列为空，返回`false`，否则将队首元素赋值给`value`，然后释放互斥锁，返回`true`。

### `bool back(T &value)`

- 作用：获取队列的队尾元素，并将其存储在传入的`value`参数中。
- 实现：获取互斥锁，如果`m_size`为零，表示队列为空，返回`false`，否则将队尾元素赋值给`value`，然后释放互斥锁，返回`true`。

### `int size()`

- 作用：获取队列当前的实际大小（元素数量）。
- 实现：获取互斥锁，返回`m_size`的值，然后释放互斥锁。

### `int max_size()`

- 作用：获取队列的最大容量。
- 实现：获取互斥锁，返回`m_max_size`的值，然后释放互斥锁。

### `bool push(const T &item)`

- 作用：向队列中添加元素`item`，唤醒所有等待条件的线程。
- 实现：获取互斥锁，如果队列已满，使用条件变量`m_cond`的`broadcast`函数唤醒等待的线程，然后释放互斥锁并返回`false`。否则，将元素添加到队列的尾部，更新队列大小和尾部指针，并使用条件变量`m_cond`的`broadcast`函数唤醒等待的线程，然后释放互斥锁并返回`true`。

### `bool pop(T &item)`

- 作用：从队列中弹出元素，如果队列为空则阻塞等待。
- 实现：获取互斥锁，如果队列为空，使用条件变量`m_cond`的`wait`函数阻塞等待，直到有元素可用。一旦有元素可用，将队列的队首元素弹出并存储到传入的`item`中，更新队列大小和队首指针，然后释放互斥锁并返回`true`。

### `bool pop(T &item, int ms_timeout)`

- 作用：从队列中弹出元素，如果超时则失败。
- 实现：获取互斥锁，如果队列为空，使用条件变量`m_cond`的`timewait`函数等待指定的超时时间。如果等待超时，返回`false`。如果等待期间有元素可用，将队列的队首元素弹出并存储到传入的`item`中，更新队列大小和队首指针，然后释放互斥锁并返回`true`。

## `log`类

### 构造函数 `Log()`

- 作用：Log类的构造函数，用于创建Log对象。
- 实现：私有构造函数，不能在外部直接创建Log对象。

### 析构函数 `~Log()`

- 作用：Log类的析构函数，用于释放Log对象相关的资源。
- 实现：私有析构函数，不能在外部直接销毁Log对象。

### `static Log *get_instance()`

- 作用：用于获取日志类的单例实例（懒汉模式）。
- 实现：返回Log类的静态实例。

### `static void *flush_log_thread(void *args)`

- 作用：异步地刷新日志内容的线程函数，从阻塞队列中取出日志并写入文件。
- 实现：调用Log对象的`async_write_log`方法。

### `bool init(const char *file_name, int close_log, int log_buf_size = 8192, int split_lines = 5000000, int max_queue_size = 0)`

- 作用：初始化日志记录器，设置日志文件名、关闭日志标志、日志缓冲区大小、分割行数以及最大队列大小。
- 参数：
  - `file_name`：日志文件名。
  - `close_log`：关闭日志标志（文件标识符）。
  - `log_buf_size`：日志缓冲区大小，默认大小为8192。
  - `split_lines`：日志分割行数，默认大小为5,000,000。
  - `max_queue_size`：最大队列大小，默认大小为0，异步需要设置阻塞队列的长度，同步不需要设置。
- 返回值：true表示初始化成功，false表示初始化失败。
- 实现：设置Log对象的各个属性，并根据是否异步写日志来初始化阻塞队列。

### `void write_log(int level, const char *format, ...)`

- 作用：写入日志。
- 参数：
  - `level`：日志级别，0表示DEBUG，1表示INFO，2表示WARN，3表示ERROR。
  - `format`：格式化字符串，用于指定日志的格式。
  - 可变参数：根据格式化字符串指定的格式，传入需要写入的数据。
- 实现：根据日志级别和格式化字符串，将日志内容写入日志缓冲区。

### `void flush()`

- 作用：刷新日志，将缓冲区中的日志内容写入文件。
- 实现：获取互斥锁，将缓冲区中的日志内容写入文件，并释放互斥锁。

## 宏定义

### `LOG_DEBUG(format, ...)`

- 作用：写入DEBUG级别的日志。
- 参数：
  - `format`：格式化字符串，用于指定日志的格式。
  - 可变参数：根据格式化字符串指定的格式，传入需要写入的数据。
- 实现：如果关闭日志标志不为0，调用Log类的`write_log`方法写入DEBUG级别的日志，并调用`flush`方法刷新日志。

### `LOG_INFO(format, ...)`

- 作用：写入INFO级别的日志。
- 参数：
  - `format`：格式化字符串，用于指定日志的格式。
  - 可变参数：根据格式化字符串指定的格式，传入需要写入的数据。
- 实现：如果关闭日志标志不为0，调用Log类的`write_log`方法写入INFO级别的日志，并调用`flush`方法刷新日志。

### `LOG_WARN(format, ...)`

- 作用：写入WARN级别的日志。
- 参数：
  - `format`：格式化字符串，用于指定日志的格式。
  - 可变参数：根据格式化字符串指定的格式，传入需要写入的数据。
- 实现：如果关闭日志标志不为0，调用Log类的`write_log`方法写入WARN级别的日志，并调用`flush`方法刷新日志。

### `LOG_ERROR(format, ...)`

- 作用：写入ERROR级别的日志。
- 参数：
  - `format`：格式化字符串，用于指定日志的格式。
  - 可变参数：根据格式化字符串指定的格式，传入需要写入的数据。
- 实现：如果关闭日志标志不为0，调用Log类的`write_log`方法写入ERROR级别的日志，并调用`flush`方法刷新日志。
